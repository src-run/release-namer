#!/usr/bin/env ruby

require 'rubygems'
require 'commander'
require 'rbtagger'
require 'english'
require 'ffi/hunspell'
require 'open_uri_redirections'
require 'nokogiri'
require 'json'
require 'yaml'

class Option
  def initialize
    @enabled = Array.new
  end

  attr_accessor :listing
  attr_accessor :enabled
  attr_accessor :default
end

class OptionFormat < Option
  def initialize
    super
    @listing = {:text => 'Plain text separated by a new line.', :csv => 'Plain text separated by commas.', :json => 'Object representation conforming to http://www.json.org/', :yaml => 'Object representation conforming to http://yaml.org/'}
    @default = :text
  end
end

class OptionModifiers < Option
  def initialize
    super
    @listing = {:CC => 'conjunction', :DT => 'determiner', :IN => 'preposition', :JJ => 'adjective', :NN => 'noun', :NNS => 'noun plural', :NNP => 'noun proper', :NNPS => 'noun proper plural', :RB => 'adverb', :UH => 'interjection', :VB => 'verb', :VBD => 'verb past tense', :VBG => 'verb present participle', :VBN => 'verb past participle'}
    @default = [:JJ, :NN, :VBD]
  end

  def add(mod)
    @enabled << mod if @listing.include?(mod.intern)
  end
end

class LinkSources
  def initialize
    @links = Array.new
    @default = ['http://en.wikipedia.org/wiki/Special:Random', 'http://en.wikipedia.org/wiki/Special:Random', 'http://en.wikipedia.org/wiki/Special:Random', 'http://en.wikipedia.org/wiki/Special:Random']
  end

  attr_accessor :links
  attr_accessor :default

  def add(links)
    @links << links
  end

  def text
    clean_contents(link_contents).join(' ')
  end

  private

  def dictionary
    @dict ||= FFI::Hunspell.dict('en_US')
  end

  def clean_contents(text)
    text.reject! { |word| word.length < 4 }
    text.keep_if { |word| word =~ /^[a-z]+$/i }
    text.keep_if { |word| dictionary.check?(word) }
    text.map! { |word| word.downcase }
    text.uniq
  end

  def link_contents
    txt = String.new

    for link in @links
      web = open(link, :allow_redirections => :safe) { |f| f.read }
      dom = Nokogiri.HTML(web)
      dom.css('head,script,style,code').map { |l| l.unlink }
      txt += dom.text
    end

    txt.words
  end
end

class Generator
  def initialize(links, modifiers)
    @links, @modifiers, @separator, @suggestions = links, modifiers, String.new, Array.new
  end

  attr_writer :separator

  def suggest
    words = Array.new

    @modifiers.enabled.each do |m|
      types = tags.select { |k,v| v == m.to_s }
      types = types.keys
      words << types[rand(types.size - 1)]
    end

    words.join(@separator)
  end

  def suggestions(count)
    i, j, limit, suggestions = 0, -1, count * 2, Array.new

    while i < count
      break if j > limit
      j += 1

      possible_suggestion = suggest
      next if suggestions.include?(possible_suggestion)

      suggestions << possible_suggestion
      i += 1
    end

    suggestions
  end

  private

  def tags
    @tags ||= Hash[Brill::Tagger.new.tag(@links.text)]
  end
end

class Writer
  def initialize(links, modifiers, format)
    @links, @modifiers, @format, @verbose = links, modifiers, format, false
  end

  attr_accessor :verbose

  def write(suggestions)
    @suggestions = suggestions

    write_opts_verbose
    write_args_verbose
    write_title_verbose 'Suggestions'

    case @format.enabled
      when :json
        write_format_json
      when :yaml
        write_format_yaml
      when :csv
        write_format_csv
      else
        write_format_text
    end
  end

  def write_line(text)
    puts text
  end

  private

  def write_opts_verbose
    write_title_verbose 'Config Modifiers'
    @modifiers.enabled.each { |m| write_line_verbose sprintf '- %s', m }
  end

  def write_args_verbose
    write_title_verbose 'Source Links'
    @links.links.each { |l| write_line_verbose sprintf '- %s', l }
  end

  def write_title_verbose(text)
    write_line_verbose sprintf '%s:', text.upcase
  end

  def write_line_verbose(text)
    write_line text if @verbose && (@format.enabled == :text || @format.enabled == :csv)
  end

  def write_format_text
    @suggestions.each do |line|
      line = sprintf '- %s', line if @verbose
      write_line line
    end
  end

  def write_format_csv
    @suggestions.map! { |r| sprintf '"%s"', r }
    write_line @suggestions.join(',')
  end

  def write_format_yaml
    write_line YAML::dump(get_write_object)
  end

  def write_format_json
    write_line JSON::generate(get_write_object)
  end

  def get_write_object
    result_object = Hash.new

    if @verbose
      result_object['config_modifiers'] = Array.new
      result_object['config_links'] = @links.links
      @modifiers.enabled.each { |m| result_object['config_modifiers'] << m.to_s }
    end

    result_object['suggestions'] = @suggestions
    result_object
  end
end

class Application
  include Commander::Methods

  VERSION = '1.0.0'

  def initialize
    @format = OptionFormat.new
    @modifiers = OptionModifiers.new
    @links = LinkSources.new
    @generator = Generator.new @links, @modifiers
    @writer = Writer.new @links, @modifiers, @format
    @verbose = false
  end

  def run
    program :version, VERSION
    program :description, 'Utility to return a randomly generated list of possible "release names" using different links to create the dictionary of words used.'
    program :help, 'Authors', 'Rob Frawley 2nd <rmf@src.run>, Dan Corrigan <dfc@scribenet.com>'
    program :help, 'License', 'MIT License (https://rmf.mit-license.org)'

    global_option('-V', '--verbose', 'Enable verbose output') { @verbose = @writer.verbose = true }

    command :suggest do |c|
      c.summary = 'Generate word combinations based on requested options'
      c.description = 'Generate word combination suggestions by fetching passed url(s) and parsing their text contents for the set of words used.'
      c.syntax = 'renamr suggest [options] -- [<links>]...'
      c.example 'return two results using custom url', 'renamr suggest --results 2 "https://wikipedia.org/LED"'
      c.example 'output 20 results as json using custom modifiers', 'renamr suggest --results 20 --modifiers NN,JJ --format json'

      c.option '-r', '--results INT', Integer, 'Number of result entried to generate'
      c.option '-f', '--format STRING', String, 'Format of returned results'
      c.option '-m', '--modifiers ARRAY', Array, 'Modifiers for result generation as Penn Treebank tags'
      c.option '-s', '--separator STRING', String, 'Value placed between modifier tags'
      c.option '-F', '--list-formats', 'List available output formats'
      c.option '-M', '--list-modifiers', 'List available modifier tags'

      c.action do |args, options|
        options.default :verbose => false, :results => 10, :separator => '-', :format => 'text', :modifiers => @modifiers.default

        parse_opts options
        parse_args args

        data = @generator.suggestions options.results
        @writer.write data

        say_warning "Insufficient source variance to generate #{options.results} unique results; created only #{data.length}!" if data.length < options.results
      end
    end

    default_command :suggest
    run!
  end

  private

  def parse_opts(o)
    say_help if o.help
    say_formats if o.list_formats
    say_modifiers if o.list_modifiers

    @generator.separator = o.separator

    @format.enabled = o.format.downcase.intern
    unless @format.listing.include?(@format.enabled)
      say_error "Error: Invalid option provided as output format: #{o.format}"
      say_formats
    end

    @modifiers.enabled = @modifiers.default if o.modifiers.length == 0
    o.modifiers.each do |m|
      unless @modifiers.listing.include?(m.upcase.intern)
        say_error "Error: Invalid option provided as modifier: #{m}"
        say_modifiers
      end
      @modifiers.add(m.upcase.intern)
    end
  end

  def parse_args(args)
    args.each { |a| @links.add(a) }
    @links.links = @links.default if @links.links.length == 0
  end

  def say_formats
    say_formats_or_modifiers @format.listing
  end

  def say_modifiers
    say_formats_or_modifiers @modifiers.listing
  end

  def say_formats_or_modifiers(hash)
    @writer.write_line "TYPE  DESCRIPTION"
    @writer.write_line "----  -----------"
    hash.each { |k, v| @writer.write_line sprintf '%4s  %s', k, v }
    exit
  end

  def say_help
    command(:help).run([:suggest])
    exit
  end
end

Application.new.run if $0 == __FILE__
